\documentclass[12pt]{jreport}
\usepackage{AIthesis}
\usepackage{amsmath,amssymb}
\usepackage[dvipdfmx]{graphicx}

\newtheorem{dfn}{定義}

\begin{document}
%\pagestyle{empty}
%\begin{center}
%{\Large\bf
%}
%\end{center}

\tableofcontents

\chapter{はじめに}
生体分子ネットワーク構造や, プログラムのフローチャート図など, 
データ間の関連性がある構造を表現するために, しばしばグラフ構造が用いられる.
グラフとは有限のノード集合と, ノード間を結合するエッジ集合からなるデータ構造である.
グラフ表現されたデータから人間が情報を得るには, グラフを適切に視覚化し, 
ノード間の関係やノードの情報が分かりやすく見えていることが望ましい.
しかし, グラフを分かりやすく視覚化することは難しく, 
グラフが大規模になると人間が手作業で視覚化することは困難である.
任意のグラフからグラフの二次元描画を生成する問題は, グラフ描画問題と呼ばれ, 
今日までに多くの手法が提案されている.

グラフ描画は, 人間が理解しやすいことが望ましいが, グラフごとにノードやエッジに与えられる意味は異なり, 
人によって見易さの好みが異なるため, グラフ描画に最も良いという基準を与えることは出来ない.
そのため, グラフの特徴などを考慮した適切なグラフ描画を考えていく必要がある.

現在, グラフ描画には力学モデルによる方法などが用いられている.
グラフを力学的モデルとみなしてシミュレーションを行い, 系が安定するまで計算することで, 
グラフノード間が均衡した状態になるようなグラフ描画を求めることができる.

[ここで他のグラフ描画アルゴリズムについて述べる]

しかし, ノードの情報に着目したい場合, グラフ描画上にノード情報を表示させるために, 
ノード間に一定以上の空間を確保したいケースが考えられる.
従来のグラフ描画手法では, グラフ描画にノード間に一定以上の空間を保障することはできない.

この目的のため, 吉田英聡によって, グラフノードをパターン, グリッド状の格子点をテキストとみなした二次元点集合の近似照合によって, 
多項式時間で動作する格子状配置アルゴリズムが提案された\cite{yoshida}.
この手法により, 任意のグラフのグラフ描画において, 元々のグラフ描画の位置関係を維持しながら, 
グラフのノード間にグリッド幅以上の空白を確保したグラフ描画の生成が可能となった. 

しかし, 二次元点集合の近似照合における時間と領域の計算量は次数が高く, 
現実的なサイズのグラフ描画に対して直接適用することができなかった.
これに対し\cite{yoshida}では, kd-木分割やメッシュ状分割などでグラフを分割統治し, 大規模なグラフに実行できるようにした.
しかし, ユーザが対話的な環境で, グラフのグリッド配置アルゴリズムを利用するには, 
ユーザがストレスを感じない程度の素早い応答時間が要求され, 依然としてアルゴリズムの高速化が求められている.

そこで本研究では, 二次元点集合近似照合における格子点集合(テキスト)が, 
格子状であることに着目し, 二次元点集合近似照合を, 
グラフノード点集合(パターン)の部分集合を包含する軸平行な最小の矩形を部分点集合の境界矩形とし, 
空集合からパターン全体になるまで, サイズが1ずつ増加するような真に包含関係にある点集合列に対応する境界矩形拡張の列を考え, 
境界矩形拡張列を最小の平行移動によって格子点集合上に格子配置する問題にみなせることを利用する.

以下では, 第2章において, 任意の点集合に対する境界矩形および境界矩形拡張列と, 
境界矩形拡張列の格子配置における編集距離の定義を行い, 
境界矩形の編集距離の再帰的定義と, 時間・空間ともに$O(n^2)$の計算量で実行可能な動的計画法(DP)による解法を紹介する.
第3章では, 境界矩形拡張列の格子配置によるグリッドグラフ描画アルゴリズムについて示した後, 
アルゴリズムの実行時間と, いくつかのグリッドグラフ描画の修正法を示し, グリッドグラフ描画の結果を示す.
第4章では結論と, 今後の課題について述べる.

\chapter{境界矩形拡張列の格子配置問題とその解法}
本章では, 二次元点集合のグリッド近似照合と, 境界矩形拡張列の格子配置について述べる.
まずはじめに, これまで行われてきた研究について紹介する.

\section{これまでの研究}
二次元点集合の近似照合の定義として, 吉田\cite{yoshida}は次のように定義した.

なお, 
[定義に利用している記号の定義]

\begin{dfn}
$n$個の点集合をそれぞれ$P,Q$とする.このとき, $1 \ge i,j,k,l \ge n $について$P[i,j]$と$Q[k,l]$の編集距離$d(i,j;k,l)$を
\begin{enumerate}
\item $|P[i,j]| = |Q[k,l]| = 1$ なら $d(i,j;k,l) = 0$, 
\item $|P[i,j]| \neq |Q[k,l]|$ なら $d(i,j;k,l) = \infty$, 
\item それ以外なら $d(i,j;k,l) = \\ \min
\begin{Bmatrix}
d([i,j]_-;[k,l]_-) + |p([i,j])_R - p([i,j]_-)_R - (q([k,l])_R - q([k,l]_-)_R)|, \\
d([i,j]^-;[k,l]^-) + |p([i,j])_T - p([i,j]^-)_T - (q[k,l])_T - q([k,l])^-)_T)|
\end{Bmatrix}$
\end{enumerate}
と定義する.　$|・|$は$L_1$のノルムである.
\end{dfn}

\begin{dfn}
[ここでTとPの照合について定義]
\end{dfn}

\cite{yoshida}では, $T$と$P$の近似照合を動的計画法で計算するアルゴリズムが提案された.
二次元点集合の近似照合アルゴリズムは, $O(n^2m^4)$で動作する.

ここで, テキスト$T$が格子点集合であるならば,  
任意の部分格子点集合$T[k,l]$とパターン$P[i,j]$との編集距離は, $T[k,l]$に関係せず, $P[i,j]$ごとに一意であるといえる.
この性質を利用することで, 格子点集合と二次元点集合の近似照合は, より小さいDP表で計算可能であることを示す.

\section{境界矩形拡張列とその格子配置における編集距離}
格子配置のための二次元点集合では, パターンとなるグラフノードを表す二次元点集合に対して, 
テキストは格子点集合は次のように定義できる.
$${\rm Grid}(d) = \{ (dx, dy) | x, y \in \mathbb{N} \} (d \in \mathbb{Z})$$

[ここで境界矩形拡張列を定義する]

各々の境界矩形において, 格子配置における編集距離は次のように再帰的に定義できる.
\begin{displaymath}
\end{displaymath}

\section{解法}
境界矩形拡張列の格子配置における編集距離を計算するアルゴリズムを次に示す.

\begin{dfn}
\end{dfn}

このアルゴリズムは, 時間・計算ともに入力の点集合のサイズ$n$に対して, 最悪計算量$O(n^2)$で動作する.

\chapter{実験結果}
この章では, 境界矩形拡張列によるグラフの格子配置アルゴリズムを実装し, アルゴリズムの性能を調べる実験を行う.
プログラムはC++(MinGW32-gcc-4.6.2)で実装し, Intel Core i7-3770 CPU (3.40GHz)のマシン上で実行した. 
マシンのRAMは8.00GBだが, プログラムは32bit環境向けにコンパイルしたため, 
プログラムが利用可能なメモリアドレス領域は4GB未満であった.

\section{グラフの格子配置アルゴリズム}
境界矩形拡張列のDP表をバックトレースしながら, 
各々の点に対して, 境界矩形拡張に合わせるように点を平行移動させることで, 
$O(n)$でグラフ配置させることができる.

[格子配置アルゴリズムを書く]

\section{グラフに入力される重複した点の対策}
アルゴリズムでは考慮しないことにしたが, 
実用上では入力される二次元点集合に重複点が与えられることが考えられる.
X軸, Y軸列を安定ソートするなどして, 重複点に一意な順序関係を与えてやることで, 
格子状配置アルゴリズムを適用させることは容易であるが, 冗長な形状に展開されることもある.
元々, 重複点が与えられるということは, グラフノード間に密接な関係があると考えることが人間にとって自然であるので, 
隣接関係を維持しつつグリッド状に展開する方法をアルゴリズムの拡張として組み込んだ.

重複点は一つの点とみなしてアルゴリズムの計算を行い, 
重複点を境界矩形に追加して拡張を行う際, 
重複点を最小の境界矩形に展開し, そのサイズを境界矩形拡張の編集距離に追加することで処理した.

[重複点展開アルゴリズム]

\section{伸長したグラフの畳み込み処理}
アルゴリズムでは, 計算量の次数を下げるために右上方向にのみ拡張をするように提案した.
そのため, グリッド幅に対して密な入力が与えられた場合, 
グリッドグラフ描画は大きく右上方向に伸長した形状になる.
過度に伸長したグラフは線形に近づき, 通常の矩形ディスプレイに表示するには形状が不適切である.
また, 元々のグラフ描画において非常に隣接している点は, 
そのため, 出力が矩形に近づくようにグラフノード間の不必要な空白を畳み込み, 
グリッドグラフ描画の幅と高さを小さくする処理を後処理として行った.

[伸長の畳み込み処理アルゴリズム]

\section{実験結果}
実装したプログラムに実際に点集合を入力として与え, 
プログラムの実行時間と, 点集合のグリッド配置によるグラフの伸長を計測した.
図\ref{fig:one}, 図\ref{fig:two}は, サイズ100程度の点集合に対して, アルゴリズムを実行した結果である.
実行時間は1msec以下で動作した.
図\ref{fig:two}において, グラフ描画全体を包含する境界矩形のサイズは, ○○だけ伸長した.

次に, サイズ10000までの点集合に対して実行速度を計測するため, プログラムを実行した.
表\ref{tb:one}にその結果をまとめる.

\begin{table}[htbp]
\begin{center}
\caption{入力サイズと実行時間}
\label{tb:one}
\begin{tabular}{|c|c|} \hline
サイズ(点) & 実行時間(sec) \\ \hline \hline
1000 & 0.093 \\ \hline
2000 & 0.343 \\ \hline
3000 & 0.765 \\ \hline
4000 & 1.435 \\ \hline
5000 & 2.231 \\ \hline
6000 & 3.260 \\ \hline
7000 & 4.571 \\ \hline
8000 & 6.035 \\ \hline
9000 & bad-alloc \\ \hline
\end{tabular}
\end{center}
\end{table}

実行速度は$O(n^2)$におさまる範囲で遷移しており, 
サイズが3000程度の点集合に対しても, 十分に対話的に利用できる速度で実行された.

サイズは8000以上の入力に対しては, 実験環境ではDP表を生成するための連続した大きなヒープ領域を確保することができなかったので, 
アルゴリズムを検証することができなかった.

\begin{figure}[htbp]
\begin{center}
\includegraphics [width=100mm] {plota5.png}
\end{center}
\abovecaptionskip=-5pt
\belowcaptionskip=-10pt
\caption{Size100のグラフ}
\label{fig:one}
\end{figure}
\begin{figure}[htbp]
\begin{center}
\includegraphics [width=100mm] {plotb5.png}
\end{center}
\abovecaptionskip=-5pt
\belowcaptionskip=-10pt
\caption{矩形拡張列による格子配置}
\label{fig:two}
\end{figure}

\chapter{終わりに}
本研究では, まず点集合に対する境界矩形と境界矩形拡張列を定義し, 
境界矩形拡張列の格子配置における編集距離を再帰的に定義した.
次に, 動的計画法による境界矩形拡張列の格子配置における編集距離を, 
空間および時間ともに最悪計算量が$O(n^2)$で実行できるアルゴリズムを提案した.

そして, 境界矩形拡張列によるグラフの格子配置アルゴリズムを提案し, 
実行時間とグラフの伸長に関する実験を行った.
さらに, 重複点の展開や, グラフ展開後の畳み込み処理の追加により, 
格子配置の伸長を抑え, 元のグラフ描画における点の局所性を, 格子配置後のグラフに反映させることができた.

実装したプログラムは, サイズ3000程度まで十分に対話的に利用できるだけの速度で動作し, 
アルゴリズムが実用的な速度で利用可能な実装ができることを示した.

しかし, グラフのサイズに対して疎なグリッド幅で展開する場合, 
グリッド配置は右上方向に伸長し, グラフの全体像は線形に近づいてしまう.
2次元グラフ描画をディスプレイするモニターが一般的に矩形であることを考えると, 
一度にグラフの可能な限りの範囲をディスプレイに収めるには不適当な形状である.

よって, グリッド配置全体が矩形に近づくように整形されることが望ましい.
本研究では, グリッド配置後の畳み込み処理の実装により対応したが, 
局所的な畳み込みでは, グラフ全体の配置を大きく破壊してしまう恐れがあるため, 
グラフの全体像を踏まえたうえでの適切な整形を行う手法が必要である.

\section*{謝辞}
本研究を進めるにあたり, 細部に至るまでご指導頂いた下薗真一准教授に深く感謝いたします.
また, 日々の研究でお世話になった研究室の皆様に深く感謝の意を表します.

\renewcommand{\bibname}{参考文献}
\begin{thebibliography}{1}

\baselineskip 12pt
\bibitem{yoshida}
吉田英聡,  
二次元点集合近似照合によるグラフの格子状配置アルゴリズム, 
電子情報通信学会総合大会講演論文集 2008年 情報・システム(1),
"S-17"-"S-18",
2008-03-05

\end{thebibliography}

\end{document}
